# coding-test-practice

## 백준, 프로그래머스 풀이 

### 수학

#### 시간 복잡도
- 코드를 짰을때 이 코드가 시간이 얼마나 걸릴지 예측하는 것
- 입력의 크기 N에 대하여 시간이 얼마나 걸릴지 나타내는 방법
- Big O Nation
- 최악의 경우( Big O )에 시간이 얼마나 걸릴지 알 수 있음

#### 소수
- 임의로 N = a*b라고 했을때, a≤√N , b≥√N로 나타낼수 있으므로  √N까지만 검사하면 된다.  (O(√N)) → 제일 빠름

#### 에라토스테네스의 채
- 지워지지 않은 수 중 가장 작은 수를 제외한 모든 배수 삭제
- 6n+1 , 6n+5는 모두 소수

#### 조합 0의 개수
- nCm의 0의 개수를 구하는 문제
- n! / (n-m)! * m!
- 조합은 2와 5의 개수는 동시에 세어줘야함. 둘중 작은 개수로

---

### 다이나믹 프로그래밍- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘  

- 다이나믹 프로그래밍의 조건
    1. Overlapping Subproblem (겹치는 부분문제) 
    2. Optimal Substructure (문제의 정답을 작은 문제의 부분에서 구할 수 있을 때) 
- 각 문제를 한번만 풀어야 함 → 한번 구했으면 정답을 어딘가에 메모해놓는다 ( memoization )

---

### 브루트 포스
- 모든 경우의 수를 다 해보는 방법
- ex) 비밀번호 숫자 4자리일 경우 0000부터 9999까지 다 해보는 것 - 경우의 수 10000
- 브루트 포스로 문제를 풀기 위해서는 다음과 같은 3가지 단계
    1. 문제의 가능한 경우의 수를 계산해본다.
    2. 가능한 모든 방법을 다 만들어본다.
    3. 각각의 방법을 이용해 답을 구해본다

#### 경우의 수
- N명의 사람이 한 줄로 서는 경우의 수 → N × (N-1) × … × 1 = N!  **O(N!)**
- N명의 사람 중에서 대표 두 명을 뽑는 경우의 수 → N × (N-1) / 2!  **O(N^2)**
- N명의 사람 중에서 대표 세 명을 뽑는 경우의 수 → N × (N-1) × (N-2) / 3!  **O(N^3)**
- N명의 사람 중에서 반장 1명과 부반장 1명을 뽑는 경우의 수 → N × (N-1)  **O(N^2)**
- N명의 사람이 있을 때, 각 사람이 영화를 볼지, 보지 않을지 결정한다. 가능한 조합의 수 → 2N  **O(2^N)**

